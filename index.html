<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Tools - Merge, Split & Compress - 100% Offline</title>
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        html, body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            height: 100%;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-attachment: fixed;
        }
        
        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .glass-strong {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        /* Smooth transitions */
        * {
            transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform;
            transition-duration: 300ms;
            transition-timing-function: ease;
        }
        
        /* Pulse animation for drag-over */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
        }
        
        .pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        /* Spinner animation */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* Responsive adjustments */
        @media (max-width: 640px) {
            .glass-strong {
                padding: 1.5rem;
            }
        }
        
        /* Touch-friendly buttons */
        button, input[type="radio"] {
            min-height: 44px;
            min-width: 44px;
        }
        
        /* Hover effects */
        button:not(:disabled):hover {
            transform: translateY(-1px);
        }
        
        button:not(:disabled):active {
            transform: translateY(0);
        }
    </style>
</head>
<body class="flex items-center justify-center p-4 sm:p-6 md:p-8">
    
    <div class="glass-strong rounded-3xl shadow-2xl p-6 sm:p-8 w-full max-w-4xl">
        <!-- Header -->
        <div class="text-center mb-6 sm:mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-white mb-2">PDF Tools</h1>
            <p class="text-sm sm:text-base text-white/80">Merge, Split & Compress PDFs securely in your browser</p>
        </div>
        
        <!-- Main Content Area -->
        <div id="app">
            <!-- Content will be dynamically rendered here -->
        </div>
    </div>
    
    <!-- PDF-lib CDN -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    
    <!-- PDF.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    
    <!-- Download.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/downloadjs/1.4.7/download.min.js"></script>
    
    <!-- Application JavaScript -->
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        
        // Application state
        const state = {
            currentMode: 'merge',
            uploadedFiles: [],
            uploadedFile: null,
            splitConfig: null,
            compressConfig: {
                quality: 0.75,
                preset: 'medium'
            },
            isProcessing: false,
            totalPages: null,
            processingProgress: null,
            originalSize: null,
            compressedSize: null
        };
        
        // Initialize app
        function init() {
            console.log('PDF Merger & Splitter initialized');
            render();
        }
        
        // Update state and re-render
        function updateState(updates) {
            Object.assign(state, updates);
            render();
        }
        
        // Switch mode handler
        function switchMode(mode) {
            updateState({
                currentMode: mode,
                uploadedFiles: [],
                uploadedFile: null,
                splitConfig: null,
                totalPages: null,
                processingProgress: null,
                originalSize: null,
                compressedSize: null
            });
        }
        
        // Handle file selection
        function handleFileSelect(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            
            if (state.currentMode === 'merge') {
                // Accept multiple files in merge mode
                Array.from(files).forEach(file => {
                    addFile(file);
                });
            } else {
                // Accept single file in split/compress mode
                addFile(files[0]);
            }
        }
        
        // Validate PDF file
        async function validatePDFFile(file) {
            // Check file type
            if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {
                throw new Error('Please upload PDF files only');
            }
            
            // Check file size with mode-specific limits
            let MAX_SIZE;
            if (state.currentMode === 'merge') {
                MAX_SIZE = 200 * 1024 * 1024; // 200MB per file for merge
            } else if (state.currentMode === 'split') {
                MAX_SIZE = 1024 * 1024 * 1024; // 1GB for split
            } else if (state.currentMode === 'compress') {
                MAX_SIZE = 1024 * 1024 * 1024; // 1GB for compress
            }
            
            if (file.size > MAX_SIZE) {
                const limitMB = Math.round(MAX_SIZE / (1024 * 1024));
                throw new Error(`File size exceeds ${limitMB}MB limit for ${state.currentMode} mode`);
            }
            
            // Try to load with pdf-lib to check for encryption/corruption
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, { 
                    ignoreEncryption: false 
                });
                return true;
            } catch (error) {
                if (error.message.includes('encrypted') || error.message.includes('password')) {
                    throw new Error('This PDF is password-protected and cannot be processed');
                } else {
                    throw new Error('This PDF file appears to be corrupted');
                }
            }
        }
        
        // Add file to state
        async function addFile(file) {
            try {
                await validatePDFFile(file);
                
                if (state.currentMode === 'merge') {
                    const fileItem = {
                        file: file,
                        name: file.name,
                        size: file.size,
                        id: Date.now() + Math.random()
                    };
                    state.uploadedFiles.push(fileItem);
                } else {
                    state.uploadedFile = file;
                    state.originalSize = file.size;
                    // Get page count for split/compress mode
                    await loadPDFPageCount(file);
                }
                render();
            } catch (error) {
                alert(error.message);
            }
        }
        
        // Load PDF and get page count
        async function loadPDFPageCount(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                state.totalPages = pdfDoc.getPageCount();
                
                // Initialize split config for split mode
                if (state.currentMode === 'split') {
                    state.splitConfig = {
                        mode: 'individual',
                        ranges: '',
                        pageInterval: 1
                    };
                }
            } catch (error) {
                console.error('Error loading PDF:', error);
            }
        }
        
        // Update split configuration
        function updateSplitConfig(field, value) {
            if (!state.splitConfig) {
                state.splitConfig = { mode: 'individual', ranges: '', pageInterval: 1 };
            }
            state.splitConfig[field] = value;
            // Only re-render if changing mode, not when typing in inputs
            if (field === 'mode') {
                render();
            }
        }
        
        // Update compress configuration
        function updateCompressConfig(field, value) {
            state.compressConfig[field] = value;
            
            // Update quality based on preset
            if (field === 'preset') {
                if (value === 'low') state.compressConfig.quality = 0.5;
                else if (value === 'medium') state.compressConfig.quality = 0.75;
                else if (value === 'high') state.compressConfig.quality = 1.0;
            }
            
            render();
        }
        
        // Check if action button should be enabled
        function isActionEnabled() {
            if (state.isProcessing) return false;
            
            if (state.currentMode === 'merge') {
                return state.uploadedFiles.length >= 2;
            } else if (state.currentMode === 'split') {
                if (!state.uploadedFile || !state.splitConfig) return false;
                
                // Validate split configuration
                if (state.splitConfig.mode === 'range') {
                    return state.splitConfig.ranges.trim().length > 0;
                }
                return true;
            } else if (state.currentMode === 'compress') {
                return state.uploadedFile !== null;
            }
            return false;
        }
        
        // Handle action button click
        async function handleAction() {
            if (!isActionEnabled()) return;
            
            state.isProcessing = true;
            render();
            
            try {
                if (state.currentMode === 'merge') {
                    await mergePDFs();
                } else if (state.currentMode === 'split') {
                    await splitPDF();
                } else if (state.currentMode === 'compress') {
                    await compressPDF();
                }
            } catch (error) {
                alert('An error occurred while processing your PDF. Please try again.');
                console.error(error);
            } finally {
                state.isProcessing = false;
                state.processingProgress = null;
                render();
            }
        }
        
        // Merge PDFs function
        async function mergePDFs() {
            try {
                // Create a new PDF document
                const mergedPdf = await PDFLib.PDFDocument.create();
                
                // Process each uploaded file
                for (const fileItem of state.uploadedFiles) {
                    // Read file as ArrayBuffer
                    const arrayBuffer = await fileItem.file.arrayBuffer();
                    
                    // Load the PDF
                    const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                    
                    // Copy all pages from this PDF
                    const copiedPages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
                    
                    // Add each page to the merged document
                    copiedPages.forEach(page => mergedPdf.addPage(page));
                }
                
                // Serialize the merged PDF
                const pdfBytes = await mergedPdf.save();
                
                // Trigger download
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'merged.pdf';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Reset state
                updateState({
                    uploadedFiles: [],
                    isProcessing: false
                });
                
                alert('PDFs merged successfully!');
            } catch (error) {
                console.error('Merge error:', error);
                throw error;
            }
        }
        
        // Split PDF function
        async function splitPDF() {
            try {
                // Read file as ArrayBuffer
                const arrayBuffer = await state.uploadedFile.arrayBuffer();
                
                // Load the PDF
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                const totalPages = pdfDoc.getPageCount();
                
                // Determine split ranges based on mode
                let splitRanges = [];
                
                if (state.splitConfig.mode === 'individual') {
                    // Split into individual pages
                    for (let i = 0; i < totalPages; i++) {
                        splitRanges.push([i]);
                    }
                } else if (state.splitConfig.mode === 'range') {
                    // Parse page ranges
                    splitRanges = parsePageRanges(state.splitConfig.ranges, totalPages);
                } else if (state.splitConfig.mode === 'every-n') {
                    // Split every N pages
                    const interval = state.splitConfig.pageInterval;
                    for (let i = 0; i < totalPages; i += interval) {
                        const range = [];
                        for (let j = i; j < Math.min(i + interval, totalPages); j++) {
                            range.push(j);
                        }
                        splitRanges.push(range);
                    }
                }
                
                // Create and download each split PDF
                for (let i = 0; i < splitRanges.length; i++) {
                    const newPdf = await PDFLib.PDFDocument.create();
                    const pageIndices = splitRanges[i];
                    
                    // Copy pages
                    const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
                    copiedPages.forEach(page => newPdf.addPage(page));
                    
                    // Serialize
                    const pdfBytes = await newPdf.save();
                    
                    // Download
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `split-${i + 1}.pdf`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Small delay between downloads
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Reset state
                updateState({
                    uploadedFile: null,
                    splitConfig: null,
                    totalPages: null,
                    isProcessing: false
                });
                
                alert(`PDF split into ${splitRanges.length} files successfully!`);
            } catch (error) {
                console.error('Split error:', error);
                throw error;
            }
        }
        
        // Parse page ranges string (e.g., "1-3, 5-7, 9")
        function parsePageRanges(rangesStr, totalPages) {
            const ranges = [];
            const parts = rangesStr.split(',').map(s => s.trim());
            
            for (const part of parts) {
                if (part.includes('-')) {
                    // Range like "1-3"
                    const [start, end] = part.split('-').map(s => parseInt(s.trim()));
                    if (isNaN(start) || isNaN(end) || start < 1 || end > totalPages || start > end) {
                        throw new Error(`Invalid range: ${part}`);
                    }
                    const range = [];
                    for (let i = start - 1; i < end; i++) {
                        range.push(i);
                    }
                    ranges.push(range);
                } else {
                    // Single page like "9"
                    const page = parseInt(part);
                    if (isNaN(page) || page < 1 || page > totalPages) {
                        throw new Error(`Invalid page: ${part}`);
                    }
                    ranges.push([page - 1]);
                }
            }
            
            return ranges;
        }
        
        // Compress PDF function
        async function compressPDF() {
            try {
                const arrayBuffer = await state.uploadedFile.arrayBuffer();
                
                // Load PDF with pdf.js
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                const pdfDoc = await loadingTask.promise;
                const totalPages = pdfDoc.numPages;
                
                // Create new PDF with pdf-lib
                const compressedPdf = await PDFLib.PDFDocument.create();
                
                // Process each page
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    // Update progress
                    state.processingProgress = {
                        current: pageNum,
                        total: totalPages
                    };
                    render();
                    
                    // Get page
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.0 });
                    
                    // Create canvas
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    
                    // Render page to canvas
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    // Convert canvas to JPEG blob
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/jpeg', state.compressConfig.quality);
                    });
                    
                    // Convert blob to array buffer
                    const imageBytes = await blob.arrayBuffer();
                    
                    // Embed image in new PDF
                    const image = await compressedPdf.embedJpg(imageBytes);
                    const pdfPage = compressedPdf.addPage([viewport.width, viewport.height]);
                    pdfPage.drawImage(image, {
                        x: 0,
                        y: 0,
                        width: viewport.width,
                        height: viewport.height
                    });
                    
                    // Small delay to let browser breathe
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                // Serialize the compressed PDF
                const pdfBytes = await compressedPdf.save();
                state.compressedSize = pdfBytes.length;
                
                // Trigger download
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'compressed.pdf';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show results
                const reduction = ((1 - state.compressedSize / state.originalSize) * 100).toFixed(1);
                alert(`PDF compressed successfully!\\n\\nOriginal: ${formatFileSize(state.originalSize)}\\nCompressed: ${formatFileSize(state.compressedSize)}\\nReduction: ${reduction}%`);
                
                // Reset state
                updateState({
                    uploadedFile: null,
                    totalPages: null,
                    isProcessing: false,
                    processingProgress: null,
                    originalSize: null,
                    compressedSize: null
                });
            } catch (error) {
                console.error('Compress error:', error);
                throw error;
            }
        }
        
        // Drag and drop handlers
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.add('border-white', 'bg-white/20');
        }
        
        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('border-white', 'bg-white/20');
        }
        
        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('border-white', 'bg-white/20');
            
            const files = event.dataTransfer.files;
            if (!files || files.length === 0) return;
            
            if (state.currentMode === 'merge') {
                Array.from(files).forEach(file => {
                    addFile(file);
                });
            } else {
                addFile(files[0]);
            }
        }
        
        // Trigger file input click
        function triggerFileInput() {
            document.getElementById('fileInput').click();
        }
        
        // Remove file from merge list
        function removeFile(fileId) {
            state.uploadedFiles = state.uploadedFiles.filter(f => f.id !== fileId);
            render();
        }
        
        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        // Render function
        function render() {
            const app = document.getElementById('app');
            
            app.innerHTML = `
                <!-- Mode Switcher -->
                <div class="flex gap-2 mb-6 p-1 glass rounded-xl">
                    <button 
                        onclick="switchMode('merge')"
                        class="flex-1 py-3 px-4 rounded-lg font-semibold transition-all duration-300 text-sm sm:text-base ${
                            state.currentMode === 'merge' 
                                ? 'bg-white/30 text-white shadow-lg' 
                                : 'text-white/70 hover:text-white hover:bg-white/10'
                        }"
                    >
                        Merge
                    </button>
                    <button 
                        onclick="switchMode('split')"
                        class="flex-1 py-3 px-4 rounded-lg font-semibold transition-all duration-300 text-sm sm:text-base ${
                            state.currentMode === 'split' 
                                ? 'bg-white/30 text-white shadow-lg' 
                                : 'text-white/70 hover:text-white hover:bg-white/10'
                        }"
                    >
                        Split
                    </button>
                    <button 
                        onclick="switchMode('compress')"
                        class="flex-1 py-3 px-4 rounded-lg font-semibold transition-all duration-300 text-sm sm:text-base ${
                            state.currentMode === 'compress' 
                                ? 'bg-white/30 text-white shadow-lg' 
                                : 'text-white/70 hover:text-white hover:bg-white/10'
                        }"
                    >
                        Compress
                    </button>
                </div>
                
                <!-- Privacy Badge -->
                <div class="glass bg-green-500/20 border-green-400/40 rounded-xl p-4 mb-6 flex items-center gap-3">
                    <svg class="w-6 h-6 text-green-300 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path>
                    </svg>
                    <div class="flex-1">
                        <p class="text-green-100 font-semibold text-sm">
                            üîí 100% Secure & Offline. Your files never leave your device.
                        </p>
                    </div>
                </div>
                
                <!-- Upload Zone -->
                <div 
                    id="uploadZone"
                    onclick="triggerFileInput()"
                    ondragover="handleDragOver(event)"
                    ondragleave="handleDragLeave(event)"
                    ondrop="handleDrop(event)"
                    class="glass border-2 border-dashed border-white/40 rounded-2xl p-8 sm:p-12 text-center cursor-pointer transition-all duration-300 hover:border-white/60 hover:bg-white/10 hover:scale-[1.02] mb-6"
                >
                    <svg class="w-12 h-12 sm:w-16 sm:h-16 mx-auto mb-4 text-white/70" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                    </svg>
                    <h3 class="text-lg sm:text-xl font-semibold text-white mb-2">
                        ${state.currentMode === 'merge' ? 'Drop PDF files here or click to upload' : 'Drop a PDF file here or click to upload'}
                    </h3>
                    <p class="text-sm sm:text-base text-white/60">
                        ${state.currentMode === 'merge' ? 'You can select multiple PDF files' : 
                          state.currentMode === 'split' ? 'Select a single PDF file to split' :
                          'Select a single PDF file to compress'}
                    </p>
                </div>
                
                <!-- Hidden File Input -->
                <input 
                    type="file" 
                    id="fileInput" 
                    accept="application/pdf"
                    ${state.currentMode === 'merge' ? 'multiple' : ''}
                    onchange="handleFileSelect(event)"
                    class="hidden"
                />
                
                <!-- File List (Merge Mode) -->
                ${state.currentMode === 'merge' && state.uploadedFiles.length > 0 ? `
                    <div class="glass rounded-xl p-4 mb-6">
                        <h3 class="text-white font-semibold mb-3">Uploaded Files (${state.uploadedFiles.length})</h3>
                        <div class="space-y-2">
                            ${state.uploadedFiles.map(fileItem => `
                                <div class="flex items-center gap-3 bg-white/10 rounded-lg p-3">
                                    <svg class="w-8 h-8 text-red-400 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"></path>
                                    </svg>
                                    <div class="flex-1 min-w-0">
                                        <p class="text-white font-medium truncate">${fileItem.name}</p>
                                        <p class="text-white/60 text-sm">${formatFileSize(fileItem.size)}</p>
                                    </div>
                                    <button 
                                        onclick="removeFile(${fileItem.id})"
                                        class="text-red-400 hover:text-red-300 transition-colors p-2"
                                        title="Remove file"
                                    >
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                        </svg>
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
                
                <!-- Split Configuration Panel (Split Mode) -->
                ${state.currentMode === 'split' && state.uploadedFile && state.totalPages ? `
                    <div class="glass rounded-xl p-6 mb-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-white font-semibold">Split Configuration</h3>
                            <span class="text-white/80 text-sm">Total Pages: ${state.totalPages}</span>
                        </div>
                        
                        <!-- Split Mode Options -->
                        <div class="space-y-3 mb-4">
                            <label class="flex items-center gap-3 cursor-pointer">
                                <input 
                                    type="radio" 
                                    name="splitMode" 
                                    value="individual"
                                    ${state.splitConfig.mode === 'individual' ? 'checked' : ''}
                                    onchange="updateSplitConfig('mode', 'individual')"
                                    class="w-4 h-4"
                                />
                                <span class="text-white">Split into individual pages</span>
                            </label>
                            
                            <label class="flex items-center gap-3 cursor-pointer">
                                <input 
                                    type="radio" 
                                    name="splitMode" 
                                    value="range"
                                    ${state.splitConfig.mode === 'range' ? 'checked' : ''}
                                    onchange="updateSplitConfig('mode', 'range')"
                                    class="w-4 h-4"
                                />
                                <span class="text-white">Split by page ranges</span>
                            </label>
                            
                            <label class="flex items-center gap-3 cursor-pointer">
                                <input 
                                    type="radio" 
                                    name="splitMode" 
                                    value="every-n"
                                    ${state.splitConfig.mode === 'every-n' ? 'checked' : ''}
                                    onchange="updateSplitConfig('mode', 'every-n')"
                                    class="w-4 h-4"
                                />
                                <span class="text-white">Split every N pages</span>
                            </label>
                        </div>
                        
                        <!-- Range Input -->
                        ${state.splitConfig.mode === 'range' ? `
                            <div class="mt-4">
                                <label class="block text-white/80 text-sm mb-2">Page Ranges (e.g., 1-3, 5-7, 9)</label>
                                <input 
                                    type="text" 
                                    id="rangeInput"
                                    value="${state.splitConfig.ranges}"
                                    oninput="updateSplitConfig('ranges', this.value)"
                                    onchange="render()"
                                    placeholder="1-3, 5-7, 9"
                                    class="w-full px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/40 focus:outline-none focus:border-white/40"
                                />
                            </div>
                        ` : ''}
                        
                        <!-- Every N Pages Input -->
                        ${state.splitConfig.mode === 'every-n' ? `
                            <div class="mt-4">
                                <label class="block text-white/80 text-sm mb-2">Split every N pages</label>
                                <input 
                                    type="number" 
                                    id="intervalInput"
                                    value="${state.splitConfig.pageInterval}"
                                    oninput="updateSplitConfig('pageInterval', parseInt(this.value))"
                                    onchange="render()"
                                    min="1"
                                    max="${state.totalPages}"
                                    class="w-full px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/40 focus:outline-none focus:border-white/40"
                                />
                            </div>
                        ` : ''}
                    </div>
                ` : ''}
                
                <!-- Compress Configuration Panel (Compress Mode) -->
                ${state.currentMode === 'compress' && state.uploadedFile && state.totalPages ? `
                    <div class="glass rounded-xl p-6 mb-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-white font-semibold">Compression Settings</h3>
                            <span class="text-white/80 text-sm">Total Pages: ${state.totalPages}</span>
                        </div>
                        
                        <!-- Quality Presets -->
                        <div class="mb-4">
                            <label class="block text-white/80 text-sm mb-3">Quality Preset</label>
                            <div class="grid grid-cols-3 gap-2">
                                <button 
                                    onclick="updateCompressConfig('preset', 'low')"
                                    class="py-2 px-4 rounded-lg font-medium transition-all ${
                                        state.compressConfig.preset === 'low' 
                                            ? 'bg-white/30 text-white' 
                                            : 'bg-white/10 text-white/70 hover:bg-white/20'
                                    }"
                                >
                                    Low
                                </button>
                                <button 
                                    onclick="updateCompressConfig('preset', 'medium')"
                                    class="py-2 px-4 rounded-lg font-medium transition-all ${
                                        state.compressConfig.preset === 'medium' 
                                            ? 'bg-white/30 text-white' 
                                            : 'bg-white/10 text-white/70 hover:bg-white/20'
                                    }"
                                >
                                    Medium
                                </button>
                                <button 
                                    onclick="updateCompressConfig('preset', 'high')"
                                    class="py-2 px-4 rounded-lg font-medium transition-all ${
                                        state.compressConfig.preset === 'high' 
                                            ? 'bg-white/30 text-white' 
                                            : 'bg-white/10 text-white/70 hover:bg-white/20'
                                    }"
                                >
                                    High
                                </button>
                            </div>
                            <p class="text-white/60 text-xs mt-2">
                                ${state.compressConfig.preset === 'low' ? 'Maximum compression, lower quality (50%)' :
                                  state.compressConfig.preset === 'medium' ? 'Balanced compression and quality (75%)' :
                                  'Minimal compression, best quality (100%)'}
                            </p>
                        </div>
                        
                        <!-- Quality Slider -->
                        <div class="mb-4">
                            <label class="block text-white/80 text-sm mb-2">
                                Custom Quality: ${Math.round(state.compressConfig.quality * 100)}%
                            </label>
                            <input 
                                type="range" 
                                min="0.3" 
                                max="1.0" 
                                step="0.05"
                                value="${state.compressConfig.quality}"
                                oninput="updateCompressConfig('quality', parseFloat(this.value)); updateCompressConfig('preset', 'custom')"
                                class="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer"
                                style="accent-color: #667eea;"
                            />
                        </div>
                        
                        <!-- File Size Info -->
                        ${state.originalSize ? `
                            <div class="bg-white/10 rounded-lg p-3">
                                <div class="flex justify-between items-center text-sm">
                                    <span class="text-white/70">Original Size:</span>
                                    <span class="text-white font-semibold">${formatFileSize(state.originalSize)}</span>
                                </div>
                            </div>
                        ` : ''}
                        
                        <!-- Warning -->
                        <div class="mt-4 bg-yellow-500/20 border border-yellow-400/40 rounded-lg p-3">
                            <p class="text-yellow-100 text-xs">
                                ‚ö†Ô∏è Compression is CPU-intensive. Large PDFs may take several minutes to process.
                            </p>
                        </div>
                    </div>
                ` : ''}
                
                <!-- Action Button -->
                <button 
                    onclick="handleAction()"
                    ${!isActionEnabled() ? 'disabled' : ''}
                    class="w-full py-4 px-6 rounded-xl font-bold text-lg transition-all duration-300 ${
                        isActionEnabled() 
                            ? 'bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white shadow-lg hover:shadow-xl transform hover:scale-105' 
                            : 'bg-white/10 text-white/40 cursor-not-allowed'
                    }"
                >
                    ${state.isProcessing ? `
                        <span class="flex items-center justify-center gap-2">
                            <svg class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Processing...
                        </span>
                    ` : state.currentMode === 'merge' ? 'Merge PDFs' : 
                        state.currentMode === 'split' ? 'Split PDF' : 'Compress PDF'}
                </button>
                
                <!-- Processing Overlay -->
                ${state.isProcessing ? `
                    <div class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50">
                        <div class="glass-strong rounded-2xl p-8 text-center max-w-md w-full mx-4">
                            <svg class="animate-spin h-12 w-12 text-white mx-auto mb-4" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <p class="text-white text-lg font-semibold">Processing your PDF...</p>
                            ${state.processingProgress ? `
                                <div class="mt-4">
                                    <p class="text-white/80 text-sm mb-2">
                                        Processing page ${state.processingProgress.current} of ${state.processingProgress.total}
                                    </p>
                                    <div class="w-full bg-white/20 rounded-full h-2">
                                        <div 
                                            class="bg-gradient-to-r from-blue-500 to-purple-600 h-2 rounded-full transition-all duration-300"
                                            style="width: ${(state.processingProgress.current / state.processingProgress.total * 100).toFixed(1)}%"
                                        ></div>
                                    </div>
                                    <p class="text-white/60 text-xs mt-2">
                                        ${((state.processingProgress.current / state.processingProgress.total) * 100).toFixed(0)}% complete
                                    </p>
                                </div>
                            ` : `
                                <p class="text-white/60 text-sm mt-2">Please wait</p>
                            `}
                        </div>
                    </div>
                ` : ''}
            `;
        }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
